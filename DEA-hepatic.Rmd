---
title: "Differential Expression Analysis for hepatic diseases"
output: html_document
date: "2023-12-13"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r, import_libraries, echo=FALSE, warning=FALSE, message=FALSE}
library(tidyverse)
library(readxl)
library(openxlsx)
library(ggplot2)
library(ggpubr)
library(ggrepel)
library(factoextra)
library(Rtsne)
library(broom)
library(DEqMS)
library(ggvenn)
library(enrichR)
library(clusterProfiler)
library(enrichplot)
library(org.Hs.eg.db)
library(msigdbr)
library(pheatmap)
library(grid)
```


```{r, import_files, echo=FALSE, warning=FALSE, message=FALSE}
data <- read_csv("median_centered_data.csv")
temp_quant_data <- read_csv("sample-feature.csv")
clinical_info <- read_csv("DA samples with classifications_20221206.csv")
```

## Differential Expression analysis for hepatic diseases

# Introduction

Differential expression analyses help to determine if protein levels are different between two conditions. Thus, the first step is to define groups. The PCA and the boxplots from individual peptides showed two potential groups that could render useful results from a DEA when compared to all the rest. On the one hand, **infectious diseases** show several proteins whose levels differ from those of all the other diseases. This pattern is followed by pyelonephritis, penumonia, sepsis and necrotizing soft tissue infection. However, it is not followed by viral hepatitis-related cirrhosis, which was also classified as an infectious disease in this data set. Instead, viral hepatitis-related cirrhosis would be part of the second promising group: **hepatic diseases**. This group would be made up of four diseases which were assigned different classes in this data set: hepatocellular cancer, fatty liver disease, chronic liver disease and the aforementioned viral hepatitis-related cirrhosis.

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Samples from patients with infectious diseases except for VHRC
hepatic_temp <- clinical_info %>% filter(Disease == "Viral hepatitis related cirrhosis" | Disease == "Hepatocellular cancer" | Disease == "Chronic Liver Disease (CLD)" | Disease == "Fatty Liver Disease") 
hepatic <- unique(hepatic_temp$sample_id)
hepatic <- colnames(temp_quant_data)[str_detect(colnames(temp_quant_data), paste(hepatic, collapse = '|'))]

# Non-infectious samples samples 
non_hepatic_temp <- clinical_info %>% filter(!(Disease == "Viral hepatitis related cirrhosis" | Disease == "Hepatocellular cancer" | Disease == "Chronic Liver Disease (CLD)" | Disease == "Fatty Liver Disease"))
non_hepatic <- unique(non_hepatic_temp$sample_id)
non_hepatic <- colnames(temp_quant_data)[str_detect(colnames(temp_quant_data), paste(non_hepatic, collapse = '|'))]
```

```{r preparing_data, echo=FALSE, warning=FALSE, message=FALSE}

#Filter peptides that appear in less than 50% of the samples
# Calculate the threshold for 50% of samples
threshold <- ncol(temp_quant_data) * 0.5

# Filter rows that have data for at least 50% of the samples
quant_data <- temp_quant_data[rowSums(!is.na(temp_quant_data)) >= threshold, ]

```

# T-tests with corrections

A t-test will be performed to statistically compare the means of the all the targeted proteins between the two defined groups with the aim of determining whether any differences are likely to stem from biological variation instead of happening by chance. This test statistic would follow a Student's t-distribution under the null hypothesis that there is no difference. Therefore, it is a parametric test. However, since the hypothesis is simultaneously being tested multiple times, the significance threshold needs to be made stricter to avoid getting false positive. The reason behind it being that it becomes increasingly likely to mistakenly reject a null hypothesis as the number of tests increases. Here, over 200 tests are being performed simultaneously, for which a p-value threshold of 0.05 could mean more than 10 false positives. Thus, two commonly used correction methods will be tested: FDR-based and Bonferroni. 

The false discovery rate represents the percentage (or rate) of significant features which are actually null (Storey & Tibshirani, 2003). This method uses the q-value, which estimates the pFDR by rejecting the null hypothesis for a result which as that or a smaller q-value. In other words, it is the proportion of false positives in all positives. A q-value of 0.05 means that 5% of the features belonging to the null hypothesis will be incorrectly deemed significant. Similarly to the p value, the q value gives each feature its own individual measure of significance. 

Similarly, the Bonferroni correction is meant to counter the increased probability of running into a Type I error by setting a new a significance level *alpha/m*, which means basically dividing the level of significance by the number of tested hypotheses. Here, the "bonferroni" method in p.adjust performs multiplies each p value by the number of tested hypothesis (208) and thus returns the Bonferroni-currected values. Bonferroni is a especially stringent method which can really reduce the number of false positives for a large *m* (Aggarwal & Yadav, 2016). However, the trade-off is the increase of false negatives. 


```{r t_test_FDR, echo=FALSE, message=FALSE, warning=FALSE}

# Perform t-test for every protein (row)
ttest_res <- apply(quant_data, 1, function(x, test_grp, ref_grp) {
  tidy(t.test(as.numeric(x[test_grp]),
              as.numeric(x[ref_grp]),
              na.action = 'na.omit'))},
  test_grp = hepatic, ref_grp = non_hepatic)

# Format results
ttest_res <- as.data.frame(do.call(rbind.data.frame, ttest_res))  
colnames(ttest_res)[1] <- 'FC'
rownames(ttest_res) <- quant_data$`...1`
ttest_res$Peptide <- quant_data$`...1`

# P-value adjustment (correction)
ttest_res$adj.p <- p.adjust(ttest_res$p.value, method = 'fdr')
ttest_res <- ttest_res[order(ttest_res$adj.p, decreasing = FALSE), ]

# Save lists of differentially expressed proteins (DEPs) for enrichment analysis

up <- ttest_res$Peptide[ttest_res$adj.p < 0.05 & ttest_res$FC > 0]
up <- unlist(strsplit(up, ';'))

down <- ttest_res$Peptide[ttest_res$adj.p < 0.05 & ttest_res$FC < 0]
down <- unlist(strsplit(down, ';'))

writeLines(up, sep = '\n', con = '´Hepatic_proteins_ttest.txt')
writeLines(down, sep = '\n', con = 'Non-hepatic_proteins_ttest.txt')

# Save t-test results and quant data for DEPs
write.csv(ttest_res, 'Hepatic_vs_non-hepatic_ttest.csv')
ttest_deps <- rownames(ttest_res[ttest_res$adj.p < 0.05,])
write.csv(quant_data[rownames(quant_data) %in% ttest_deps,],
          "C:/Users/Uhlen Lab/Documents/Andrea/DA/Project Course 2/quant_data_deps_hepatic.csv")

x <- quant_data[quant_data$`...1` %in% ttest_deps,]
y <- as.data.frame(t(clinical_info))
write.csv(y, 'test_hepatic.csv')
```

```{r t_test_bonferroni, echo=FALSE, warning=FALSE, message=FALSE}

# P-value adjustment (correction)
ttest_res$bonferroni <- p.adjust(ttest_res$p.value, method = 'bonferroni')
ttest_res <- ttest_res[order(ttest_res$bonferroni, decreasing = FALSE), ]

# Save lists of differentially expressed proteins (DEPs) for enrichment analysis

up_b <- ttest_res$Peptide[ttest_res$bonferroni < 0.05 & ttest_res$FC > 0]
up_b <- unlist(strsplit(up_b, ';'))

down_b <- ttest_res$Peptide[ttest_res$bonferroni < 0.05 & ttest_res$FC < 0]
down_b <- unlist(strsplit(down_b, ';'))

writeLines(up_b, sep = '\n', con = 'Hepatic_proteins_ttest_bonf.txt')
writeLines(down_b, sep = '\n', con = 'Non-hepatic_proteins_ttest_bonf.txt')

# Save t-test results and quant data for DEPs
write.csv(ttest_res, 'Hepatic_vs_non-hepatic_ttest_bonf.csv')
ttest_deps <- rownames(ttest_res[ttest_res$bonferroni < 0.05,])
write.csv(quant_data[rownames(quant_data) %in% ttest_deps,],
          "C:/Users/Uhlen Lab/Documents/Andrea/DA/Project Course 2/quant_data_bonf_deps.csv")

x_b <- quant_data[quant_data$`...1` %in% ttest_deps,]
y_b <- as.data.frame(t(clinical_info))
#z <- bind_rows(x, y)
write.csv(y_b, 'bonf_test_hepatic.csv')
```

```{r venn_diagram, echo=FALSE, warning=FALSE, message=FALSE}
# P-values
pval_deps <- rownames(ttest_res[ttest_res$p.value < 0.05,])

# Bonferroni correction
bonf_deps <- p.adjust(ttest_res$p.value, method = 'bonferroni')
bonf_deps <- rownames(ttest_res[bonf_deps < 0.05,])

# FDR correction
fdr_deps <- p.adjust(ttest_res$p.value, method = 'fdr')
fdr_deps <- rownames(ttest_res[fdr_deps < 0.05,])

# Venn diagram of DEPs
ggvenn(list('No correction' = pval_deps,
            'Bonferroni' = bonf_deps,
            'FDR' = fdr_deps))
```

**No p-value correction**: 180


**FDR (Benjamini-Hochberg) correction**: 179


---- Up in hepatic diseases: 18


---- Down in hepatic diseases: 161


**Bonferroni correction**: 153


---- Up in hepatic diseases: 8


---- Down in hepatic diseases: 145


# Volcano plots

The volcano plot is a visual tool to represent the results from the t-test. The p-value (-log10 transformed) is shown on the y-axis and the log2-fold change on the x-axis. Beyond applying multiple hypotheses testing corrections, applying a fold change cut-off can also reduce the FDR while tending to keep the true positives (Pascovici et al., 2016). For visualization purposes, the x-axis is going to be limited to (-7,7) fold-change. This excludes 16 peptides, whose names can be found in the list underneath the plot. 

```{r DEA_FDR, echo=FALSE, warning=FALSE, message=FALSE}
# Proteins to label in the plot
ttest_up <- ttest_res[ttest_res$adj.p < 0.05 & ttest_res$FC > 1,]
ttest_down <- ttest_res[ttest_res$adj.p < 0.05 & ttest_res$FC < -1,]

ggplot(ttest_res, aes(x = FC, y =  -log10(adj.p))) +
  geom_vline(xintercept = c(0, -1, 1), linetype = 'dashed') +
  geom_hline(yintercept = -log10(0.05), linetype = 'dashed') +
  geom_point(color = 'grey30', alpha = 0.8) +
  geom_point(data = ttest_up, color = '#FF8089', alpha = 0.8) + 
  geom_point(data = ttest_down, color = '#0097A2', alpha = 0.8) +
  geom_label_repel(data = rbind(ttest_up, ttest_down), aes(label = Peptide), size = 2) + 
  labs(x = 'Fold change', y = '-log10(q-value)', title = 'Hepatic vs non hepatic diseases - FDR corrected t-test') +
  theme_bw() +
  xlim(-7,7)
```


```{r DEA_Bonferroni, echo=FALSE, warning=FALSE, message=FALSE}
# Proteins to label in the plot
ttest_up_b <- ttest_res[ttest_res$bonferroni < 0.05 & ttest_res$FC > 1,]
ttest_down_b <- ttest_res[ttest_res$bonferroni < 0.05 & ttest_res$FC < -1,]

ggplot(ttest_res, aes(x = FC, y =  -log10(bonferroni))) +
  geom_vline(xintercept = c(0, -1, 1), linetype = 'dashed') +
  geom_hline(yintercept = -log10(0.05), linetype = 'dashed') +
  geom_point(color = 'grey30', alpha = 0.8) +
  geom_point(data = ttest_up, color = '#FF8089', alpha = 0.8) + 
  geom_point(data = ttest_down, color = '#0097A2', alpha = 0.8) +
  geom_label_repel(data = rbind(ttest_up_b, ttest_down_b), aes(label = Peptide), size = 2) + 
  labs(x = 'Fold change', y = '-log10(q-value)', title = 'Hepatic vs non hepatic diseases - Bonferroni-corrected t-test') +
  theme_bw() +
  xlim(-7,7)
```

```{r,  echo=FALSE, warning=FALSE, message=FALSE}
excluded_peptides_b <- ttest_res[ttest_res$FC > 7 | ttest_res$FC < -7,]
print(excluded_peptides_b[c("FC", "adj.p", "bonferroni")])
```

The clustering and principal component analyses can now be repeated based only on the differentially expressed proteins to visualize how well they can separate the samples belonging to hepatic and non-hepatic diseases from each other. The first heatmap shows all the differentially expressed peptides that reached a significant FDR corrected value, while the second one only shows the peptide with the highest mean per protein. Having added a column to classify hepatic and non-hepatic diseases, it has now become aparent that the hepatic diseases do form several clusters in which the significant downregulation of many proteins stands out. 

```{r echo=FALSE, warning=FALSE, message=FALSE}
hepatic_colors <- 
  c("Hepatic" = "red3",
     "Non-hepatic" = "lightblue3")

```

```{r all_sig_heatmap,  fig.width=15, fig.height=10, echo=FALSE, warning=FALSE, message=FALSE}

# Extracting sample, disease, and class from column names
col_ann <- data.frame(colnames(quant_data)) %>%
  separate(col = "colnames.quant_data.", into = c("sample_id", "Disease", "Class"), sep = "_")

# Remove the first row which contains the original column names
col_ann <- col_ann[-1, ]

# Set row names using the 'Sample' column
rownames(col_ann) <- col_ann$sample_id

# Remove the 'Sample' column to avoid duplication
col_ann <- col_ann[, -1]

col_ann <- col_ann %>%
  mutate(Hepatic = ifelse(Disease == "Viral hepatitis related cirrhosis" | Disease == "Hepatocellular cancer" | Disease == "Chronic Liver Disease (CLD)" | Disease == "Fatty Liver Disease", "Hepatic", "Non-hepatic"))

col_ann <- col_ann["Hepatic"]

## Based on DEPs
ttest_deps <- ttest_res %>% filter(adj.p < 0.05)
ttest_deps <- ttest_deps$Peptide

# Taking '...1' to remove after setting row names
significant_quant_data <- quant_data[quant_data$`...1` %in% ttest_deps, ]

# Store the column used for row names
row_names_column <- significant_quant_data$`...1`

# Remove the column used for row names
significant_quant_data <- subset(significant_quant_data, select = -`...1`)

# Set row names using the stored column
rownames(significant_quant_data) <- row_names_column

colnames(significant_quant_data) <- gsub("_.*$", "", colnames(significant_quant_data))

imputed_sig_data <- apply(significant_quant_data, 2, function(x) ifelse(is.na(x), mean(x, na.rm = TRUE), x))

# Cluster samples (columns)
cor_col <- cor(imputed_sig_data, method = 'pearson')
dist_col <- as.dist(1-cor_col)

# Cluster proteins (rows)
cor_row <- cor(t(imputed_sig_data), method = 'pearson')
dist_row <- as.dist(1-cor_row)

# Plot heatmap
all_sig_hepatic_heatmap <- pheatmap(as.matrix(imputed_sig_data),
         width = 24,  # Adjust the width of the plot
         height = 20,  # Adjust the height of the plot
         breaks = seq(-2, 2, length.out = 101),
         scale = 'row',
         clustering_distance_cols = dist_col,
         clustering_distance_rows = dist_row,
         clustering_method = 'average',
         annotation_col = col_ann,
         show_colnames = F,
         border_color = NA,
         annotation_colors = list(Hepatic = hepatic_colors),
         #color = viridis::inferno(20, direction = -1),
         fontsize = 10,
         fontsize_row = 4,
         fontzise_col = 4,
         angle_col = 90,
         main = 'Pearson correlation distance')

svg("all_sig_hepatic_heatmap.svg", width = 15, height = 8)
all_sig_hepatic_heatmap
dev.off()

all_sig_hepatic_heatmap
```


```{r,  fig.width=15, fig.height=10, highest_sig_heatmap, echo=FALSE, warning=FALSE, message=FALSE}

# Taking '...1' to remove after setting row names
significant_quant_data <- quant_data[quant_data$`...1` %in% ttest_deps, ]


#Getting mean per peptide across the dataset
#Temporary dataset with only the peptide names
data_temp <- separate(significant_quant_data, "...1", into = c("Protein", "Peptide"), sep = "-")
data_temp_2 <- data_temp[, -(1:2)]
rownames(data_temp_2) <- data_temp$Peptide
 
peptide_means <- rowMeans(data_temp_2, na.rm = TRUE)
data_temp$pep_means <- peptide_means

# Group by 'Protein' and filter rows where 'pep_means' is equal to the maximum 'pep_means'
highest_pep <- data_temp %>%
  group_by(Protein) %>%
  filter(pep_means == max(pep_means))

highest_pep <- unite(highest_pep, "protein-peptide", c("Protein", "Peptide"), sep = "-")
highest_pep <- column_to_rownames(highest_pep, var = "protein-peptide")
highest_pep <- highest_pep[, -ncol(highest_pep)]

# Extracting sample, disease, and class from column names
col_ann <- data.frame(colnames(highest_pep)) %>%
  separate(col = "colnames.highest_pep.", into = c("sample_id", "Disease", "Class"), sep = "_")

colnames(highest_pep) <- gsub("_.*$", "", colnames(highest_pep))

imputed_highest_pep <- apply(highest_pep, 2, function(x) ifelse(is.na(x), mean(x, na.rm = TRUE), x))

# Set row names using the 'sample_id' column
rownames(col_ann) <- col_ann$sample_id

# Remove the 'sample_id' column to avoid duplication
col_ann <- col_ann[, -1]

col_ann <- col_ann %>%
  mutate(Hepatic = ifelse(Disease == "Viral hepatitis related cirrhosis" | Disease == "Hepatocellular cancer" | Disease == "Chronic Liver Disease (CLD)" | Disease == "Fatty Liver Disease", "Hepatic", "Non-hepatic"))

col_ann <- col_ann["Hepatic"]

# Cluster samples (columns)
cor_col <- cor(imputed_highest_pep, method = 'pearson')
dist_col <- as.dist(1 - cor_col)

# Cluster proteins (rows)
cor_row <- cor(t(imputed_highest_pep), method = 'pearson')
dist_row <- as.dist(1 - cor_row)

# Plot heatmap
max_sig_pep_hepatic_heatmap <- pheatmap(as.matrix(imputed_highest_pep),
         width = 24,  # Adjust the width of the plot
         height = 20,  # Adjust the height of the plot
         breaks = seq(-2, 2, length.out = 101),
         scale = 'row',
         clustering_distance_cols = dist_col,
         clustering_distance_rows = dist_row,
         clustering_method = 'average',
         annotation_col = col_ann,
         show_colnames = F,
         border_color = NA,
         annotation_colors = list(Hepatic = hepatic_colors),
         #color = viridis::inferno(20, direction = -1),
         fontsize = 8,
         fontsize_row = 5,
         fontzise_col = 4,
         angle_col = 90,
         main = 'Pearson correlation distance')


svg("max_sig_pep_hepatic_heatmap.svg", width = 15, height = 8)
max_sig_pep_hepatic_heatmap
dev.off()

max_sig_pep_hepatic_heatmap
```

Regarding the PCA, the variance explained by each the first 3 PCs is very similar and the data points belonging to the hepatic diseases occupy very similar positions to those seen in the PCA plot which considered all peptides. The group formed by the hepatic diseases is relatively well segretated into the bottom left corner, indicating that both PC1 and PC2 have a strong effect on these samples. In the case of PC3, which did not seem to provide much more information initially, the samples belonging to hepatic diseases seem to show a tendency to go towards the bottom left corner again. This better separates them from the group of infectious diseases. All of the features in the PCs from this analysis were also in the same PC for the initial PCA. 

```{r DEPs_based_PCA, echo=FALSE, warning=FALSE, message=FALSE}
# Formatting data
significant_quant_data <- quant_data[quant_data$`...1` %in% ttest_deps, ]
significant_quant_data <- data.frame(significant_quant_data)
row_names <- significant_quant_data$`...1`
rownames(significant_quant_data) <- row_names
significant_quant_data <- significant_quant_data[, -1]


pca_res_deps <- prcomp(t(na.omit(significant_quant_data)), center = TRUE, scale = TRUE)

```


```{r, fig.width=10, fig.height=7, echo=FALSE, warning=FALSE, message=FALSE}
# Get the eigenvalues (=variance explained)
eig <- get_eig(pca_res_deps)
eig$PC <- 1:nrow(eig)

# Proportion of variance explained by principal components
fviz_eig(pca_res_deps, main = 'Variance explained', addlabels = TRUE) + # barplot of variance explained
  geom_point(data = eig[1:10,], # add cumulative variance explained (points)
             mapping = aes(x = PC, y = cumulative.variance.percent,
                           color = 'Cumulative variance')) +
  geom_line(data = eig[1:10,], # add cumulative variance explained (line)
            mapping = aes(x = PC, y = cumulative.variance.percent,
                          color = 'Cumulative variance')) +
  geom_text(data = eig[1:10,], # add cumulative variance explained (labels)
            mapping = aes(x = PC, y = cumulative.variance.percent,
                          label = paste0(round(cumulative.variance.percent, 1), '%')),
            nudge_y = 5) +
  scale_color_manual(values = 'firebrick') +
  theme(legend.position = 'bottom') +
  guides(color = guide_legend(title = ''))
```


```{r define_factors, echo=FALSE, warning=FALSE, message=FALSE}

id_disease_class <- data.frame(colnames(significant_quant_data))
id_disease_class <- separate(id_disease_class, "colnames.significant_quant_data.", into = c("sample_id", "Disease", "Class"), sep = "_")

id_disease_class_hepatic <- id_disease_class %>%
  mutate(Hepatic = ifelse(Disease == "Viral.hepatitis.related.cirrhosis" | Disease == "Hepatocellular.cancer" | Disease == "Chronic.Liver.Disease..CLD." | Disease == "Fatty.Liver.Disease", "Hepatic", "Non-hepatic"))

hep_factor <- as.factor(id_disease_class_hepatic$Hepatic)

hepatic_colors <- 
  c("Hepatic" = "red3",
     "Non-hepatic" = "lightblue3")

disease <- as.factor(id_disease_class_hepatic$Disease)

disease_shapes <- c("Hepatocellular.cancer"= 1, "Chronic.Liver.Disease..CLD." = 2, "Fatty.Liver.Disease"=3, "Viral.hepatitis.related.cirrhosis" = 4, "Healthy"=5, "Melanoma" = 6, "Pediatric.Diseases" = 7, "Acute.coronary.syndrome"=8, "Venous.thromboembolism..suspected." = 9, "Venous.thromboembolism" = 9, "Occlusion.or.stenosis.of.the.carotid.artery" = 10, "Pyelonephritis" = 11, "Pneumonia" = 12, "Sepsis" = 13, "Necrotizing.soft.tissue.infection" = 14, "NAFLD" = 15, "Myositis" = 16, "Rheumatoid.arthritis" = 17, "Systemisk.Lupus.Erythematosus" = 18, "Scleroderma" = 19, "Multiple.sclerosis"=20, "Sjögrens.syndrome"=21, "Bipolar.disorder"=22, "Schizophrenia"=23, "Pancreatic.cancer"=24, "Obesity"=25)
```


```{r, PCA_plot_1-2, fig.width=15, fig.height=10, echo=FALSE, warning=FALSE, message=FALSE}

# Plot PCA of samples
suppressWarnings(fviz_pca_ind(pca_res_deps,
             alpha.ind = 0,# Adjust transparency
             repel = TRUE,
             label = "none") + 
  geom_point(aes(colour = hep_factor, shape = disease), size = 1.2, alpha = 0.7, stroke = 1.5) + 
  scale_color_manual(values = hepatic_colors, guide = guide_legend(title = "Hepatic")) +
  scale_shape_manual(values = disease_shapes, guide =  guide_legend(title = "Disease")) +
  theme(legend.position = "bottom",
        legend.direction = "horizontal",
        legend.box.background = element_rect(colour = "black", linewidth = 0.5),
        legend.key.size = unit(0.3, "cm"),
        legend.margin = margin(t = 5, r = 5, b = 5, l = 5, unit = "pt")) +
  guides(color = guide_legend(reverse = TRUE),
         shape = guide_legend(reverse = TRUE))
)
```


```{r dims1-2, fig.width=15, fig.height=10, echo=FALSE, warning=FALSE, message=FALSE}
# Plot PCA with variable contributions
fviz_pca_biplot(pca_res_deps, 
                repel = TRUE,
                axes = c(1,2),
                geom.ind = 'point',
                alpha.ind = 0.2,
                select.var = list('contrib' = 15), # top 10 contributing variables
                col.var = 'contrib') 
```


```{r contributions_1-2, echo=FALSE, warning=FALSE, message=FALSE}
# Barplot of variable contribution to the two first principal components
fviz_contrib(pca_res_deps, choice = 'var', top = 20, axes = c(1,2))+ 
  theme(axis.text.x = element_text(angle = 0, hjust = 1)) +
  coord_flip()               
``` 


```{r, PCA_plot_2-3, fig.width=15, fig.height=10, echo=FALSE, warning=FALSE, message=FALSE}

# Plot PCA of samples
suppressWarnings(fviz_pca_ind(pca_res_deps,
             alpha.ind = 0,# Adjust transparency
             axes = c(2,3),
             repel = TRUE,
             label = "none") + 
  geom_point(aes(colour = hep_factor, shape = disease), size = 1.2, alpha = 0.7, stroke = 1.5) + 
  scale_color_manual(values = hepatic_colors, guide = guide_legend(title = "Hepatic")) +
  scale_shape_manual(values = disease_shapes, guide =  guide_legend(title = "Disease")) +
  theme(legend.position = "bottom",
        legend.direction = "horizontal",
        legend.box.background = element_rect(colour = "black", linewidth = 0.5),
        legend.key.size = unit(0.3, "cm"),
        legend.margin = margin(t = 5, r = 5, b = 5, l = 5, unit = "pt")) +
  guides(color = guide_legend(reverse = TRUE),
         shape = guide_legend(reverse = TRUE))
)
```

```{r dims2-3, fig.width=15, fig.height=10, echo=FALSE, warning=FALSE, message=FALSE}
# Plot PCA with variable contributions
fviz_pca_biplot(pca_res_deps, 
                repel = TRUE,
                axes = c(2,3),
                geom.ind = 'point',
                alpha.ind = 0.2,
                select.var = list('contrib' = 15), # top 10 contributing variables
                col.var = 'contrib') 
```


```{r contributions_2-3, echo=FALSE, warning=FALSE, message=FALSE}
# Barplot of variable contribution to the two first principal components
fviz_contrib(pca_res_deps, choice = 'var', top = 20, axes = c(2,3))+ 
  theme(axis.text.x = element_text(angle = 0, hjust = 1)) +
  coord_flip()               
``` 

**List of most influential variables and their loading:**

```{r, echo=FALSE, warning=FALSE, message=FALSE}
# Get the loadings of principal components
loadings <- pca_res_deps$rotation

# Extract the most influential variables for the first principal component, for instance
# Change '1' to the principal component number you want to explore
PC1_loadings <- loadings[, 1]  # Loadings for PC1
PC2_loadings <- loadings[, 2]
PC3_loadings <- loadings[, 3]

# Sort variables by their absolute loading values for PC1
sorted_PC1_loadings <- sort(abs(PC1_loadings), decreasing = TRUE)
sorted_PC2_loadings <- sort(abs(PC2_loadings), decreasing = TRUE)
sorted_PC3_loadings <- sort(abs(PC3_loadings), decreasing = TRUE)

# Select the top 'n' influential variables for PC1 (e.g., top 10 variables)
top_influential_variables_PC1 <- names(sorted_PC1_loadings)
top_influential_variables_PC2 <- names(sorted_PC2_loadings)
top_influential_variables_PC3 <- names(sorted_PC3_loadings)

# Create a dataframe with the top influential variables and their loadings for PC1
top_influential_variables_df_PC1 <- data.frame( Variable = top_influential_variables_PC1)
top_influential_variables_df_PC2 <- data.frame( Variable = top_influential_variables_PC2)
top_influential_variables_df_PC3 <- data.frame(Variable = top_influential_variables_PC3)

print(c(top_influential_variables_df_PC1, top_influential_variables_df_PC2, top_influential_variables_df_PC3))

data_frames <- list(
  PC1 = top_influential_variables_df_PC1,
  PC2 = top_influential_variables_df_PC2,
  PC3 = top_influential_variables_df_PC3
)

# Specify the output file path
output_file <- "top_sig_hepatic_PCA_variables.xlsx"

# Write each data frame to a separate sheet in the Excel file
write.xlsx(data_frames, file = output_file)
```

**Shared peptides with the full PCA (all):**

```{r, echo=FALSE, warning=FALSE, message=FALSE}

list1 <- data_frames
list2 <- excel_sheets("top_PCA_variables.xlsx")
list2 <- lapply(list2, function(sheet) readxl::read_excel("top_PCA_variables.xlsx", sheet = sheet))


# Function to extract unique names from a list of data frames
get_unique_names <- function(lst, columns) {
  unique_names <- unique(unlist(lapply(lst, function(df) {
    unlist(lapply(df[, columns, drop = FALSE], unique))
  })))
  return(unique_names)
}

# Extract unique names from each list
unique_names_list1 <- data.frame(list1)
unique_names_list2 <- data.frame(list2)

# Find common names between the two lists
common_names_PC1 <- intersect(unique_names_list1$Variable, unique_names_list2$Variable)
common_names_PC2 <- intersect(unique_names_list1$Variable.1, unique_names_list2$Variable.1)
common_names_PC3 <- intersect(unique_names_list1$Variable.2, unique_names_list2$Variable.2)

# Number of common names
num_common_names <- length(common_names_PC1) + length(common_names_PC2) + length(common_names_PC3)

c(common_names_PC1, common_names_PC2, common_names_PC3)
```


# References

Aggarwal, S., & Yadav, A. K. (2016). False discovery rate estimation in proteomics. Statistical Analysis in Proteomics, 119-128.

Pascovici, D., Handler, D. C., Wu, J. X., & Haynes, P. A. (2016). Multiple testing corrections in quantitative proteomics: A useful but blunt tool. *Proteomics, 16*(18), 2448-2453.

Storey, J. D., & Tibshirani, R. (2003). Statistical significance for genomewide studies. *Proceedings of the National Academy of Sciences, 100*(16), 9440-9445.
